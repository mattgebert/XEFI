"""
Module for the XEFI calculation of a basic set of layers.
"""

import numpy as np, numpy.typing as npt
from typing import Callable
from XEFI.models.results import BaseResult
import warnings
import scipy.constants as sc

en2wav: float = 2 * sc.pi * sc.e / (sc.h * sc.c)
"""
Conversion factor energy in eV to wavevector in Angstroms

.. math::
    \lambda = (h \times c) / (E \times e)
    \k_0 = 2 \pi / \lambda
"""

# Support for KKCalc
try:
    from kkcalc.models.polynomials import asp_complex

    has_KKCalc = True
except ImportError:
    has_KKCalc = False


class BasicResult(BaseResult):
    """
    Result class for the basic XEF model, inheriting from BaseResult.

    This class has the same properties as BaseResult, but is generated by the basic XEF model.
    """


class BasicRoughResult(BasicResult):
    """
    Result class for the basic XEFI model with roughness, inheriting from BaseResult.

    This class extends the BaseResult to include additional properties specific to the basic model,
    in particular the roughness contributions to the modified Fresnel coefficients.

    Attributes
    ----------
    ...
    """

    def __init__(self):
        # Declare the properties
        self.rough_S: npt.NDArray[np.complex128] | None = None
        """Roughness reflection factor for each interface (L, M, N)"""
        self.rough_T: npt.NDArray[np.complex128] | None = None
        """Roughness transmission factor for each interface (L, M, N)"""
        self.fresnel_r_rough: npt.NDArray[np.complex128] | None = None
        """The Fresnel reflection coefficients with roughness for each interface (L, M, N)"""
        self.fresnel_t_rough: npt.NDArray[np.complex128] | None = None
        """The Fresnel transmission coefficients with roughness for each interface (L, M, N)"""
        # Call the parent constructor
        super().__init__()

    def reset(self):
        """
        Clear/initialise the result object attributes to None.
        """
        self.rough_S = None
        self.rough_T = None
        self.fresnel_r_rough = None
        self.fresnel_t_rough = None
        # Reset the parent properties
        super().reset()


def XEF(
    beam_energy: list[float] | npt.NDArray[np.floating] | float,
    angles: list[float] | npt.NDArray[np.floating] | float,
    z: list[float] | npt.NDArray[np.floating],
    refractive_indices: (
        list[complex]
        | npt.NDArray[np.complexfloating]
        | list[Callable]
        | list["asp_complex"]
    ),
    z_roughness: list[float] | npt.NDArray[np.floating] | None = None,
    *,
    layer_names: list[str] | None = None,
    input_checking: bool = True,
    generate_figure: bool = False,
) -> BasicResult | BasicRoughResult:
    """
    Calculate the complex X-ray Electric Field for a set of layers.

    Parameters
    ----------
    beam_energy : list[float] | npt.NDArray[np.floating] | float
        The beam energy(s) in eV. Can be a single value or an array of values.
    angles : list[float] | npt.NDArray[np.floating] | float
        The angles in degrees at which to calculate the XEFI. Can be a single value or an array of values.
    z : list[float] | npt.NDArray[np.floating]
        The interface locations in Angstroms. Must be a list or array of floats.
    refractive_indices : list[complex] | npt.NDArray[np.complexfloating] | list[Callable] | list["asp_complex"]
        The refractive indices for each layer. Can be a list of complex numbers, a numpy array of complex numbers,
        a list of `KKCalc` `asp_complex` objects, or a list of Callable functions that return complex numbers.
    z_roughness : list[float] | npt.NDArray[np.floating] | None, optional
        The roughness of the interfaces in Angstroms. If provided, it should be a list or array of floats with the same length as `z`.
        If None, no roughness is applied, by default None.
    layer_names : list[str] | None, optional
        The names of the layers corresponding to the refractive indices, by default None.
    input_checking : bool, optional
        Whether to perform input checking, by default True.
    generate_figure : bool, optional
        Whether to generate a figure of the XEFI, by default False.

    Returns
    -------
    BasicResult | BasicRoughResult
        An instance of BasicResult or BasicRoughResult containing the calculated XEFI data.
        A BasicRoughResult is returned if `z_roughness` is provided, otherwise a BasicResult is returned.
    """
    # Initialise a result
    result = BasicRoughResult() if z_roughness is not None else BasicResult()

    ## Collect the properties
    # Beam energy
    beam_energy = np.atleast_1d(beam_energy)
    """The beam energy(s) in eV (with length L)"""
    # Energy number
    L: int = beam_energy.shape[0]
    """Number of energies."""
    result.L = L
    # Angles
    angles = np.atleast_1d(angles)
    theta = np.deg2rad(angles)
    """The angles in radians (with length M)"""
    # Angle number
    M: int = angles.shape[0]
    """Number of angles."""
    result.M = M
    # Interface locations
    z = np.asarray(z, dtype=np.float64, copy=True)
    # Interface number
    N: int = z.shape[0] - 1
    """Number of interfaces."""
    result.N = N
    # Roughness
    if z_roughness is not None:
        z_roughness = np.asarray(z_roughness, dtype=np.float64, copy=True)
        assert z_roughness.ndim == 1

    # Refractive indices require verification based on supplied data type
    ref_idxs: npt.NDArray[np.complexfloating]
    """A numpy array of complex refractive indices across all energies (L) and layers (N)."""
    if (
        isinstance(refractive_indices, np.ndarray)
        and L > 1
        and refractive_indices.ndim == 2
        and refractive_indices.shape[1] == N + 1
        and refractive_indices.shape[0] == L
    ):
        # Valid refractive indices for multiple energies
        if issubclass(refractive_indices.dtype.type, np.complexfloating):
            ref_idxs = refractive_indices.copy()
        else:
            raise ValueError(
                f"Refractive indices must be a numpy array of complex numbers \
                              for multiple energies. Dtype was instead {refractive_indices.dtype}"
            )

    elif (
        isinstance(refractive_indices, np.ndarray)
        and L == 1
        and refractive_indices.ndim == 1
        and refractive_indices.shape[0] == N + 1
    ):
        # Valid refractive indices for a single energy
        if issubclass(refractive_indices.dtype.type, np.complex128):
            ref_idxs = refractive_indices.copy()
        else:
            raise ValueError(
                f"Refractive indices must be a numpy array of complex numbers \
                                for a single energy. Dtype was instead {refractive_indices.dtype}"
            )

    elif (
        isinstance(refractive_indices, list)
        and all(isinstance(n, (int, float, complex)) for n in refractive_indices)
        and L == 1
        and len(refractive_indices) == N + 1
    ):
        # Valid refractive indices for a single energy
        ref_idxs = np.asarray(refractive_indices, dtype=np.complex128, copy=True)
        if sum(ref_idxs.imag != 0) == 0:
            warnings.warn(
                "Refractive indices provided are all real. \
                This may not be correct for X-ray calculations.",
                UserWarning,
            )

    elif (
        isinstance(refractive_indices, list)
        and has_KKCalc
        # Allow float for vacuum or air - i.e. no material absorption.:
        and all(isinstance(n, (float, asp_complex)) for n in refractive_indices)
        and len(refractive_indices) == N + 1
    ):
        # Valid refractive indices for a single energy using KKCalc
        ref_idxs = np.zeros((L, N + 1), dtype=np.complex128)
        for i, mat_n in enumerate(
            refractive_indices
        ):  # Iterate over the layers, apply the energy.
            if isinstance(mat_n, asp_complex):
                ref_idxs[:, i] = mat_n.refractive_index(
                    beam_energy
                )  # Apply the energy to the KKCalc object
            else:
                ref_idxs[:, i] = mat_n + 0j  # Convert float to complex

    elif isinstance(refractive_indices, list) and all(
        callable(n) for n in refractive_indices
    ):
        # Valid refractive indices for multiple energies using Callable
        ref_idxs = np.zeros((L, N + 1), dtype=np.complex128)
        single_energy_calc: bool = (
            False  # Prevent callable from being called with multiple energies.
        )
        for i, mat_n in enumerate(
            refractive_indices
        ):  # Iterate over the layers, apply the energy.
            if L == 1:
                ref_idxs[0, i] = mat_n(
                    beam_energy
                )  # Apply the energy to the Callable function
            elif single_energy_calc:
                for j in range(L):
                    ref_idxs[j, i] = mat_n(
                        beam_energy[j]
                    )  # Apply the energy to the Callable function
            else:
                if callable(mat_n):
                    try:
                        ref_idxs[:, i] = mat_n(
                            beam_energy
                        )  # Apply the energy to the Callable function
                    except TypeError | ValueError as e:
                        single_energy_calc = True
                        for j in range(L):
                            ref_idxs[j, i] = mat_n(
                                beam_energy[j]
                            )  # Apply the energy to the Callable function

    else:
        raise ValueError(
            "Refractive index values must be a list of complex numbers, \
                            a numpy array of complex numbers, a list of `KKCalc` `asp_complex` objects \
                            or a list of Callable functions for multiple energies."
        )

    ## Generate result data
    # Wavevector magnitude in vacuum
    k0: npt.NDArray[np.floating] = en2wav * beam_energy
    """The wavevector magnitude in vacuum for each energy (L)."""
    result.k0 = k0

    # Wavevector-z in each layer
    wavevectors: npt.NDArray[np.complexfloating] = np.zeros(
        (L, M, N + 1), dtype=np.complex128
    )
    """Z-component wavevectors at each energy (L) and angle (M) for each layer (N)."""
    wavevectors[:, :, 0] = k0[:, np.newaxis] * np.cos(theta)

    # Angle of incidence in each layer
    angles_of_incidence: npt.NDArray[np.complexfloating] = np.zeros(
        (L, M, N + 1), dtype=np.complex128
    )
    angles_of_incidence[:, :, 0] = theta[
        np.newaxis, :
    ]  # Vacuum layer has no refraction

    # Calculate angles of incidence for each layer: Snell's Law
    angles_of_incidence[:, :, 1:] = np.arccos(
        np.cos(theta[np.newaxis, :, np.newaxis])
        * ref_idxs[:, np.newaxis, 0]
        / ref_idxs[:, np.newaxis, 1:]
    )
    # Calculate wavevectors for each layer
    wavevectors[:, :, 1:] = k0[:, np.newaxis, np.newaxis] * np.sqrt(
        ref_idxs[:, np.newaxis, 1:] ** 2 - np.cos(theta[np.newaxis, :, np.newaxis]) ** 2
    )
    # Small angle approximation for cosine:
    # wavevectors[:, :, 1:] = k0[:, np.newaxis, np.newaxis] * angles_of_incidence[:, :, 1:]

    result.wavevectors = wavevectors
    result.angles_of_incidence = angles_of_incidence

    # Calculate the Fresnel coefficients for each layer
    fresnel_r = np.zeros((L, M, N), dtype=np.complex128)
    """The Fresnel reflection coefficients for each interface (L, M, N)"""
    fresnel_t = np.zeros((L, M, N), dtype=np.complex128)
    """The Fresnel transmission coefficients for each interface (L, M, N)"""
    fresnel_t[:, :, :] = (
        2 * wavevectors[:, :, :-1] / (wavevectors[:, :, :-1] + wavevectors[:, :, 1:])
    )
    fresnel_r[:, :, :] = fresnel_t[:, :, :] - 1.0
    # fresnel_r[:, :, :] = (
    #     (wavevectors[:, :, :-1] - wavevectors[:, :, 1:]) /
    #     (wavevectors[:, :, :-1] + wavevectors[:, :, 1:])
    # )
    result.fresnel_r = fresnel_r
    result.fresnel_t = fresnel_t

    # Calculate the critical angles
    critical_angles: npt.NDArray[np.floating] = np.sqrt(2 - (1 - ref_idxs[1:].real))
    result.critical_angles = critical_angles

    # Calculate the field strenghts, using roughness contributions if provided
    X = np.zeros((L, M, N + 1), dtype=np.complex128)
    """The ratio of the field strengths for each layer (L, M, N)"""
    R = np.zeros((L, M, N + 1), dtype=np.complex128)
    """The reflection field strengths for each layer (L, M, N)"""
    T = np.zeros((L, M, N + 1), dtype=np.complex128)
    """The transmission field strengths for each layer (L, M, N)"""
    T[:, :, 0] = 1.0  # Vacuum layer has no transmission
    if z_roughness is not None:
        assert isinstance(result, BasicRoughResult)
        S: npt.NDArray[np.complex128] = np.exp(
            -2
            * z_roughness[np.newaxis, np.newaxis, :] ** 2
            * wavevectors[:, :, :-1]
            * wavevectors[:, :, 1:]
        )
        """Roughness reflection factor for each interface (L, M, N)"""
        T: npt.NDArray[np.complex128] = np.exp(
            -2
            * z_roughness[np.newaxis, np.newaxis, :] ** 2
            * (wavevectors[:, :, :-1] + wavevectors[:, :, 1:]) ** 2
        )
        """Roughness transmission factor for each interface (L, M, N)"""

        fresnel_r_rough: npt.NDArray[np.complex128] = fresnel_r * S
        """The Fresnel reflection coefficients with roughness for each interface (L, M, N)"""
        fresnel_t_rough: npt.NDArray[np.complex128] = fresnel_t * T
        """The Fresnel transmission coefficients with roughness for each interface (L, M, N)"""

        # Store the roughness results in the result object
        result.rough_S = S
        result.rough_T = T
        result.fresnel_r_rough = fresnel_r_rough
        result.fresnel_t_rough = fresnel_t_rough

        # Recursively calculate the ratio of the field strengths
        for i in range(N - 1, -1, -1):
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * (z[i + 1] - z[i]))
                if i != N - 1
                else 0.0  # at i+1 = N, semi-infinite X_{N} = 0.
            )
            X[:, :, i] = (
                (fresnel_r_rough[:, :, i] + a_jp1**2 * X[:, :, i + 1])
                / (1 + a_jp1**2 * X[:, :, +1] * fresnel_r_rough[:, :, i])
                if i != N - 1
                else fresnel_r_rough[:, :, i]
            )
        result.X = X

        # Calculate the field strengths
        for i in range(0, N):
            a_j = np.exp(-1j * wavevectors[:, :, i] * z[i])
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * z[i + 1])
                if i + 1 != N
                else 0.0  # at i+1 = N, semi-infinite X_N = 0.0
            )
            T[:, :, i + 1] = (a_j * T[:, :, i] * fresnel_t_rough[:, :, i]) / (
                1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r_rough[:, :, i]
            )
            R[:, :, i] = a_j**2 * X[:, :, i] * T[:, :, i]
        result.R = R
        result.T = T
    else:
        for i in range(N - 1, -1, -1):
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * (z[i + 1] - z[i]))
                if i != N - 1
                else 0.0  # at i+1 = N, semi-infinite X_{N} = 0.
            )
            X[:, :, i] = (
                (fresnel_r[:, :, i] + a_jp1**2 * X[:, :, i + 1])
                / (1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r[:, :, i])
                if i != N - 1
                else fresnel_r[:, :, i]
            )
        result.X = X

        # Calculate the field strengths
        for i in range(0, N):
            a_j = np.exp(-1j * wavevectors[:, :, i] * z[i])
            a_jp1 = (
                np.exp(1j * wavevectors[:, :, i] * z[i + 1])
                if i + 1 != N
                else 0.0  # at i+1 = N, semi-infinite X_N = 0.0
            )
            T[:, :, i + 1] = (a_j * T[:, :, i] * fresnel_t[:, :, i]) / (
                1 + a_jp1**2 * X[:, :, i + 1] * fresnel_r[:, :, i]
            )
            R[:, :, i] = a_j**2 * X[:, :, i] * T[:, :, i]
        result.R = R
        result.T = T

    # Finishing up - reduce dimensions if L or M is 1.
    result.X = np.squeeze(X)[()]
    result.R = np.squeeze(R)[()]
    result.T = np.squeeze(T)[()]
    result.wavevectors = np.squeeze(wavevectors)[()]
    result.angles_of_incidence = np.squeeze(angles_of_incidence)[()]
    result.refractive_indices = np.squeeze(ref_idxs)[()]

    # Return the result
    return result
